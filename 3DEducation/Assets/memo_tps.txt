memo_tps.txt

함수의 overload(함수의 중북정의)
:함수가 이름은 같고 매개변수 리스트가 다른 것.

함수의 override(함수의 재정의)
:부모클래스의 함수와 동일한 형태로 만들되
실제 정의의 구현은 다르게 하는 것.


Dictionary <-- 자료구조 중에 해쉬 자료구조. 검색을 위해 만들어진 자료구조. 시간복잡도는 O(1)
SortedDictionary <-- 자료구조 중에 균형이진탐색트리 시간복잡도 O(log N)




OOP객체지향 프로그래밍 코드의 4가지 특징

추상화 abstraction

은닉화 encapsulation

상속화 inheritance

다형성 polymorphism
 virtual + override + 부모클래스 참조 타입으로 다루기를 결합해서 만든다.


import
외부의 파일 자원을 유니티로 가져와 '에셋'화하는 동작

Asset
유니티가 사용하는 게임 자원resource


Scene Graph
장면 그래프
3D 상의 게임오브젝터들을 담고 있는 '자료구조'


변환 Transform
:자기자신으로의 사상(함수, 매핑mapping)



렌더링 Rendering
:3D공간상에 정점 단위의 데이터를 
2D공간상에 픽셀 단위의 데이터를 이미지화시켜(프레임 이미지)표시하는 것

렌더링 파이프라인 Rendering Pipeline
렌더링의 일련의 공정들의 집합

일반적인 렌더링 파이프라인의 구조
===================================================================================================
응용프로그램 단계					기하 단계									  래스터라이즈 단계
===================================================================================================
응용프로그램이						월드변환	   (카메라변환)뷰변환	  투영변환
그래픽 처리가 필요한				 이동변환       이동변환
데이터와 명령문을					 회전변환       회전변환
조직화하여							 비례변환          X
그래픽 처리 장치로 
넘기는 작업
===================================================================================================
CPU, RAM							GPU, VRAM

									정점 데이터를 다룬다.						  픽셀 데이터를 다룬다.
									연속적인 공간을 다룬다.						  불연속적인 공간을 다룬다.



셰이딩 shading: '픽셀의 최종 색상'을 결정한다. (픽셀의 최종 색상 = f(물체의 색상, 텍스처, 조명) )

Material 재질: How to Shading. 어떻게 셰이딩할지에 대한 '데이터'와 '방법'을 담은 개념
'방법' Shader세이더: 세이딩하는 작은 조각프로그램

Texture: 이미지 데이터

 알베도
 :빛 반사에 의한 색상


유니티에서 길이 단위는 1Unit을 쓴다.
유니티의 1unit은 실제 세계의 1m에 대응된다.
유니티의 무게단위는 1이 1kg에 대응된다.

rigidbody에
 Force계열: 물리 1초동안 주는 힘
 Impelse:        1프레임 동안 주는 힘

삼각형Triangle
:3개의 정점(vertex)이 선으로 이루어진 도형



3D그래픽스에서는
삼각형을 기본단위로 사용한다.
삼각형들을 모아서 임의의 입체도형(폴리곤 polygon)을 만든다


메쉬Mesh
<--삼각형들의 집합( 정점들의 집함 )


this: '객체' 자기자신을 가리키는 참조 변수, 암죽적으로 선언되어 있다. 생략 가능하다.




//변수의 선언과 초기화
int tA = 3;
//정수를 값으로 가지는 변수


int* tpA = nullptr;
//주소를 값으로 가지는 변수

class CSlime
{
	int mA = 0;

	private void Move();

}//사용자 정의 타입

CSlime tSlime;//객체


벡터의 회전rotation이란?
크기는 그대로이고 방향이 바뀌는 것

0_tps_followCam_0
 :간단한 3rd Person Shooter 카메라 시점과 이동을 만들어보자.

  캐릭터는 이동하고
  카메라는 따라간다.

  캐릭터 이동
    Rotate
	Translate


카메라 워크

instPCahr_Simple: 가장 간단한 카메라 워크 구현은 
		플레이어블 캐릭터에 계층구조 상 하위 오브젝트로 카메라를 두고
		자신이 워하는 시점으로 조정해두는 것이다.


스크립트를 이용한 TPS카메라워크
	LateUpdate <-- 렌더링된 경과를 담기 위해 이 위치에 코드
	Transform.LookAt <-- 뷰좌표계의 기저basis의 회전에 관한 것이다.

	Lerp을 이용한 DampTrace 추적감쇠 <-- 지연 카메라



직선의 방정식, 일차 함수 표준형
 y = ax + b

 게임 프로그래밍에서는 위의 직선의 방정식보다는
 '직선의 벡터 방정식'을 더 자주 사용한다.

 P = P0 + (P1 - P0) * t
  위치 + 벡터 * 스칼라

 임의의 점: P

 P0---------P----------------P1
 시점   임의의 점           종점



다음은 벡터와매개변수로 나타낸 선형보간 식이다.
P = (1-t) * P0 + t*P1 




0_tps_followCam_1
 :비교적 좀더 복잡한 ㄴ 3rd Person Shooter 카메라 시점과 이동을 만들어	보자.

  캐릭터는 이동하고
  카메라는 따라간다.

  캐릭터 이동 
	Character Controller 컴포넌트

오일러 수치해석에 의한 이동 코드를 이해해야 해당 컴포넌트를 이용 가능하다.
속도 = 거리의 변화량 / 시간의 변화량
V = deltaS / deltaT
  = (S[n] - s[n-1]) / deltaT

  V * deltaT = S[n] - S[n-1]

  S[n] = S[n-1] + V * deltaT



가속도 = 속도의 변화량 / 시간의 변화량
A = deltaV / deltaT
  = (V[n] - V[n-1]) / deltaT

   V * deltaT = V[n] - V[n-1]

   V[n] = V[n-1] + A * deltaT


   캐릭터 컨트롤러는
   Rigidbody물리를 활용하지 않는 캐릭터를 만들 때 사용한다.

   Slope Limit: 올라갈 수 있는 경사 한계 설정
   Step Offset: 계단으로 취급할 수 있는 높이 한계 설정
   Skin Width:  두 콜라이더가 서로 스킨 너비만큼 관통 가능
   <-- 이를테면 두 캐릭터가 이동하거나 할 때 서로 부딫히면 이 정도 허용오차는 
   주어 서로 끼는 현상을 방지하기 위한 옵션이다.

   지터링 Jittering
   :물결치듯 불안정하게 떨리는 현상

   다음은 메뉴얼에서 권장하는 수치이다.
   <--이를 기준으로 조정하여 사용하면 되겠다.

   신장: 2unit(2,)
   보폭: 0.1~0.4unit
   Slope Limit: 90 degree
   Skin Width: 최소 0.01초과, Radius의 10%보다 크게
   Min Move Distance:0
   

   transform.TransformDirection
   '로컬 좌표계 공간'에서 '월드 좌표계 공간'으로 direction을 변환 하는 함수이다. 


카메라
	
	i)vector = Quaternion * vector



사원수 Quaternion:

복소수는 다음과 같이 표기한다. ( 대수적인 표현 )

a + bi
실수부 + 허수부

복소수 * 복소수 가
2차원 평면에서 임의의 위치의 회전이 된다.

라는 사실을 보고 해밀턴 수학자는 이런 생각을 했다.
 3차원 공간에서 임의의 위치의 회전이 되는 '수'는 없을까?

 그래서 만들어낸 것이 항 4개로 표현하는 사원수Quaternion이다.
 그리고 이것은
 3차원 공간에서의 임의의 위치의 회전(벡터 포함)을 대수적을 표현한다.
 크기가 1인 사원수: 단위사 원수 


 q = w + 
 xi + yi = zk

  1    -1
 p = gpg
 회전된 방향 = 다윈사원수 * 원래방향 * 1


 데카르트(직교) 좌표계
 (x,y)

 극 좌표계
 x = r*cosT
 y = r*sinT 

 degree
 :한바퀴를 360등분한 것중에 하나를 1도라고 한 것
 측정치
 수학의 개념은 아니다.

 radian
 :반지름이 r인 원의 r만큼의 호의 길이를 1라디안이라고 한다.
 이것은 원의 개념으로부터 나온 것이므로 수학적 개념이다.
 (실수 연산에 통합된다)
 <-- 그러므로, 수학함수나 게임엔진에서는 내부적으로 radian각도개념을 사용한다.

 
 몇가지 회전의 종류를 비교해보자.
 i)   유니티 에디터 상에서 zxy순서로 90,90,90도 회전시키고 결과를 보자.		<--오일러 각의 의한 회전
 ii)  사원수의*연산자로 사원수 연산 적용 결과를 살펴보자.	 <--사원수의 의한 회전
 iii) transform.Rotate결과를 살펴보자.	 <--사원수의 의한 회전
 iv)  Quternion에서 제공하는 Euler함수를 적용 결과를 살펴보자.  <--오일러 각의 의한 회전
 v)   직접 회전행렬을 만들어 정점들에 적용, 결과를 보자. <-- 오일러 각의 의한 회전



 사원수의 곱셈이 3차원 공간에서
 임의의 벡터의의 회전을 나타내난 이유:

 벡터의 회전이란
 크기는 그대로이고, 방향변경되는 것을 말한다.

 임의의 벡터를 사원수에 곱셈하여
 임의의 회전된 벡터를 얻는 식은 다음과 같다.

 p' = qpq^-1

 p':   임의의 벡터
 p:    임의의 회전된 벡터
 q:    회전에 해당하는 사원수
 q^-1: q의 역수

 회전에 사용되는 사원수는 단위사원수이다.(크기가 1인 사원수)
 그러므로 q와 q^-1은 단위 사원수이다.
 그러므로
 q^-1와 q*는 같다
 (q*은 q의 공액이라고 한다. 벡터부가 반대인 사원수이다.)

 그러므로 다음은 다르게도 쓸 수 있다.
 p' = qpq^-1

 p' = qpq*

 크기를 구하자

 ||p'|| = ||qpq*||
 ||p'|| = ||q||, ||p||, ||q*||

 ||p'|| = ||p||

 방향을 구하자 
 p' = qpq*
	= [Qs Qv][0 Pv][Qs-Qv]

	그리고 이를 사원수의 연산을 활용해 풀이하면
	= [0 V]
	
	임의의 회전된 방향의 벡터가 나온다

	정리하면
	사원수의 곱셈의 결과가
	크기는 변하지 않고 임의의 회전된 방향의 벡터가 나오므로
	사원수의 곱셈은
	3차원에서 벡터의 회전을 대수적으로 표현한다고 할 수 있다.



2_thrad_vs_conroutine

	프로세스Process: 프로그램 실행의 흐름
	   스레드Thread: 실행 흐름의 최소 단위

	  프로세스는 N(N>=1)개의 스레드로 이루어진다.

	  스레드 1개의 프로세스 1개 ---> 싱글 스레드 프로그램
	  스레드 N개(N>=2)에 프로세스 1개 ---> 멀티 스레드 프로그램

	  멀티 스레드 프로그램의 목적: 
		단위시간 당 병렬 처리(동시에 실행흐름을 여러개 실행한다)를 통해 더 많은 연산을 하려는 것이 목적이다.


	C#에서 제공되는 
	코루틴Coroutine은 병렬 처리를 흉내내기 위해 만들어진 개념이다.
	다만, 
	코루틴은 실제로 병렬 처리되는 것은 아니다.
	코드만 그런 형태를 취한다.


3_AI_Navigation
	
	<--A*알고리즘: 게임업계에서 길찾기에 사용하는 대표적인 알고리즘(필수)
	f = g + h
	f: 현재 판단가능한 최선의 비용
	g: 현재지점까지의 실제비용
	h: 현재지점에서 최종지점까지의 추정비용 


	유니티에서 제공하는 인공지능 길찾기

	AI Navigation 패키지 설치가 필요하다. (2022.3.4f1 기준)

	다음 세가지 컴포넌트가 주요하다.

	i) NavMeshSurface
		새롭게 추가된 컴포넌트이다. (기존에는 장면 단위로 관리되었었다.)

		지형 정보를 구축한다. (Bake(미리 정보를 계산하여 '파일'로 가지고 있는다)한다 라고 표현한다.)
		장면이름과 같은 폴더가 만들어지고 그곳에 에셋 파일로 저장된다.

		여러가지 지형 정보 생성 방식을 지원한다.(예: volume, ...)

		<--Generate Links
		:( OffMesh Link기능이다)
		서로 떨어진 메쉬를 이동할 수 있게 연결 정보를 만드는 것이다.
		지형정보에 대해 전역적으로 생성된다.
		방향은 한 방향이다.(높은데서 낮은데로)


		<--OffMeshLink컴포넌트
			컴포넌트를 부착하여 만든다.
			시작점 끝점 지정 가능하다.
			베이크 정보에 포함되지 않는다.

		<--NavMeshLink컴포넌트
			컴포넌트를 부착하여 만든다.
			시작점, 끝점 지정 가능하다.
			베이크 정보에 포함되지 않는다.

			서로 다른 베이크된 지형 정보 사이에 이동도 가능하다.

	ii) NavMeshAgent
		
		미리 베이크된 지형정보를 기반으로
		길찾기를 수행, 게임 오브젝트를 이동시킨다.

	iii) NavMeshObstacle

		실행중에 작동하는 동적 장애물을 만드는 컴포넌트

		Carve옵션을 켜야만 작동한다.
		Carve Only Stationary On 움직임이 없다고 판단되었을 때 장애물로 인식하도록 연산한다. <-- 실행중 연산이 비교적 작다.
		Carve Only Stationary Off 움직이는 동안에도 장애물로 인식하도록 연산한다. <--실행중 연산이 많다

	iv) NavMeshModifire

		NavMesh Data 수정(변경)자

		예) 만약 이동불가 지역을 만드려면
		해당 지역에 해당하는 게임오브젝트에 NavMeshModifire컴포넌트를 부착하고
		Override Area/Area Type을 Not Walkable로 설정한다.

		Navigation윈도우의 Area탭에서
		사용자 정의 커스텀 Area도 만들 수 있다.
			Cost설정도 가능하다.


4_Behaviour Tree

	행동 트리
	'트리' 자료구조의 구조와 체계를 가져와 
	임의의 '행동'을 결정하는 게임 인공지능 이론으로 사용한다.

	
	게임 인공지능의 주요한 두가지 기법
	  i)FSM: Finite State Machine 유한 상태 기계

		유한한 상태들의 추상적인 기계

		구현 방법에는 다음과 같은 것들이 있다.
		가) if if if 
		나) if else if else if
		다) switch				  <-- 속도는 O(1), 다만 유지보수 관리에 문제가 있다
		라) 함수의 참조테이블     <-- 속도는 O(1), switch보다는 유지보수 하기 좋다
		마) State Pattern(공부)   <-- OOP를 기반으로 한 Design Pattern

	  ii)Behaviour Tree

	  가)사전배경 지식
	    자료구조  Data Structure: N개의 자료들을 담아두는 구조물
		  <--구조에 따라 자료구조마다 특성이 다르다.
		  
		배열 Array: 동일한 타입의 원소들의 연속적인 메모리 블럭
		링크드 리스트 Linked List: 노드가 데이터와 링크를 가지고 각각의 링크에 의해 선형(1:1)으로 연결된 자료구조 
		트리 Tree: 1:n의 비선형 자료구조, 계층형 자료구조
		<--Level order방식으로 순회한다.

		순회Traverse: 모든 노드를 중복없이 한번씩 방문하는 것.

	  나)행동트리의 노드들의 전제조건

	  노드는 반드시 다음 리턴값 중 하나를 가진다.
	  Success <-- True
	  Failure <-- False
	  (Running)

	  노드의 종류는 다음과 같은 것들이 있다.

	  Composite Node
		 Sequence: N개의 하위(자식) 노드를 가진다.
		 <-- 하위 노드들 중 하나라도 false를 리턴하면 Sequence도 false를 리턴하며 그 즉시 종료한다.

		 Selector: N개의 하위(자식) 노드를 가진다.
		 <-- 하위 노드들 중 하나라도 true를 리턴하면 Selector도 true를 리턴하며 그 즉시 종료한다.

	  Inverter: 반대, 즉 Not 연산자에 해당한다. 한개의 하위 노드를 가진다.

	  ActionNode: 실제'행동'이 담긴다. 0개의 하위노드

		트리자료구조

	  
	  CEnemyBT는 다음의 인공지능을 수행하는 에이전트이다.

	  수류탄을 소지하고 있으며 주인공 캐릭터를 추적하여 
	  일정 범위 안에 들어오면 수류탄을 투척한다.
	  수류탄이 없으면 주인공 캐릭터를 피해 원래 지점으로 이동한다.


5_TPS_Light

TPS

	탄 만 들기 구현 방식 두가지
	i) 투사체 방식
	ii) 레이캐스트 방식

	
	기본적인 탄환 궤적 알고리즘
	 i)일반 탄환

	 ii)조준 탄환

	 iii)원형 탄환


	 탄환 발사 루틴
		가)발사 시작 지점 설정
		나)탄환의 속도 설정
		다)탄환 활성화

	탄착지점포물선궤적
		직선의 방정식 y = ax + b <-- 두 점을 알면 구할 수 있다.
		포물선의 방정식 y - ax^2 + bx + c <-- 세 점을 알면 구할 수 있다.

		그런데 여기서 두 점만 주어진다. (발사시지점, 탄착지점)


	 이 기능을 구현하기 위해 다음을 유도
		속도, 가속도의 정의를 미분으로 표현 <-- 무한의 개념
		적분 <-- 임의의 시간의 '위치'를 가속도, 초기속도, 초기위치, 경과시간의 식으로 만들 수 있다.
		2차원에서 가로축의 성분, 세로축의 성분을 분리
		데카르트 좌표계로 다루기를 극좌표계(각도와 거리)로 다루기로 개념 전환
		식을 풀어내기 <-- 각도와 속력(속도의 크기)변수의 식으로 정리



법선벡터 Normal Vecotr
:평면에 수직인 단위벡터


수학에서 평면의 방정식
ax + by + cz + d = 0

게임 프로그래밍에서는 평면의 벡터방정식을 더 많이 사용한다.

평면의 벡터 방정식 
P dot N = d

P: 평면 위에 임의의 한점
N: 법선벡터
d: 원점에서 평면까지의 최단거리


Tag: 게임오브젝트의 꼬리표
layer: 게임오브젝트의 임의의 카테고리 분류
	<-- 다양한 용도로 활용가능하다.
	(여기서는 물리 검출 용도로 사용)


Physics.OverlapShapere
비트연산자로 레이어 마스크 적용
<-- 비트연산자 표현을 사용하는 이유
	<-- 메모리 절약을 위한 표현이다.

Rigidbody.AddExplosion 폭발력을 표현하는 함수 제공

파티클 Particle
	:N개의 작은 조각 2D 스프라이트를 이용해서 여러 가지 효과를 만드는 방법
	(요즘은 폴리곤 이용하기도 한다.)
	<--스프라이트Sprite: 작은 조각 이미지를 말한다. 유효한 이미지를 제외하고는 투명색으로 되어 있어 
						 배경과 조합되도록 만들어진 이미지이다.


Light 


 빛(조명, 광원)의 효과도 수학적 모델에 의해 만들어진다.
 광원의 방향이 해당 물체의 법선벡터의 각도에 의한 빛반사가 이루어진다. 
 예) 난반사 Diffuse 조명모델 <-- 램버트 조명 모델
 
 가장 기본적인 조명(광원)의 종류는 다음 세가지이다.
		Diretional Light 직사광원
			<-- 태양광을 모사하여 만들어짐, 방향만 영향을 미친다.
		Point Light 점광원
			<-- 거리에 따라 빛이 감쇄
		Spot Light 집중광원
			<-- 거리에 따라 빛의 감쇄, 일정 영역에만 영향을 미침

		연산 정도는 다음과 같은 순위다.
		Directional Light < Point Light < Spot Light

물체의 갯수와 연산의 갯수가 많아지면 많아질수록 연산은 점점더 많아지게 된다.
O(M*N)

<--그러므로 실행중에 조명 연산은 되도록 일어나지 않게 만드는 전략이 유효하다.


조명 모델의 두가지 큰 분류
    i)전여 조명 모델 Global Illumination Lighting Model(GI)
      <-- 직접광에 의한 음영 + 간접광에 의한 음영 + 그림자
	  장면 전체를 고려하여 조명 효과를 만드는 모델
   ii)국소 조명 모델 Local Illumination Lighting Model
	  <-- 직접광에 의한 음영(shading)


라이트 정보 만들기

	가)LightMap굽기에 대한 광원과 물체의 설정
		<--Light Baske옵션으로 설정
		<--Static Object(정적 물체, 움직임이 없는 물체)물체는 Contribute GI를 설정


	나)Light Mapping
		실시간 조명 연산을 사용하지 않고도
		조명의 효과를 내길 위한 방법이다.
		(실행중에 조명 연산이 줄어든다.)

		정적 오브젝트에 적용하는 방법이다.

		정적 게임오브젝트의 표면에 적용될 조명효과의 색상정보를
		미리 계산하여 텍스처 에셋으로 만들고
		이를 정적 게임오브젝트에 미리 텍스처 매핑한 것이다.

		실행중에 조명 연산이 없다.


	다)라이트 프로브 Light Probe
		실시간 조명 연산을 사용하지 않고도
		조명의 효과를 내길 위한 방법이다.
		(실행중에 조명 연산이 줄어든다.)

		동적dynamic 게임오브젝트에 적용하는 방법이다.

		동적 게임오브젝트 표면에 적용될 조명효과의 색상정보를
		미리 계산하여 임의읭 공간 상에 임의의 지점들에 기억시켜두고 
		실행중에 색상의 보간연산을 통해 임의의 동적 게임오브젝트에 표면에 색상을 적용한다.

		실행중에 조명 연산은 없다.
		다만, 미리 계산되어 있는 색상을 적용하는 보간연산이 일어난다.




Lighting 윈도우 
  Scene탭 <-- 장면 전체에 적용되는 GI 설정 창이다.


	Realtime Lighting 카테고리
	:실시간으로 라이팅 계산을 하는 옵션 설정이다.
	 이것을 켜두면 실행중에 연산이 늘어난다.
		<--빠르게 움직이는 광원에는 효과가 미미하다.

	Mixed Lighting 카테고리
	:GI를 미리 계산하는 옵션 설정

		subtract: '직접광에 의한 음영 + 간접광에 의한 음영 + 그림자'를 미리 계산한다.
		shadowmask: '간접광에 의한 음영 + 그림자'를 미리 계산한다. 그림자를 따로 계산하여 담는다. <-- 이것이 기본설정되어 있다.
		baked indirect: '간접광에 의한 음영'을 미리 계산한다.


	Lightmapping Setting
		Light Bake 결과로 만든 라이트맵(lightmap: 텍스처 에셋 파일) 옵션 설정창
		(라이트맵: 미리 계산해둔 결과물)



  Environment탭 <-- 간접광 중엥 환경광에 관한 설정이다.

	skybox material설정 옵션이 있다.
	<--skybox material에는 두가지 종류의 텍스처를 사용가능하다.
		6sideds <--box의 여섯면에 해당하는 텍스처가 준비된다.
		cubemap <--여섯개의 텍스처를 모아높은 텍스처 데이터이다.

		완전한 암흑을 만드려면?
		  Directional Light 비활성화
		  Environment Lighting을 color로 설정 검정색
		  Environment Reflection을 custom으로 하고 곱하기 비율은 0
		  MainCamera의 ClearFlag색상설정



6_PPS
:Post Processing Stack

일단 bulitin render papeline에서는 설치가 필요하다.

화면 후 처리 효과 <-- 쉽게 이야기하면 실시간 포토샵 효과이다.
				  <-- 즉, 실행중에 렌더링된 프레임 이미지 데이터에 별도의 효과를 주는 도구이다.

				  '카메라'와 '필름'에서 일어나는 여러 현상들을 모사하여 효과로 만든 것이다.


	unity에서 Volume과 Layer로 작동시킨다.


 Grain
	감광속도가 다른 필름에 대한 효과이다.
	감광속도가 빠른 필름은 입자가 크고 거칠다.
	감광속도가 느린 필름은 입자가 작고 부드럽다.

 Auto Exposure
	자동 노출
	<-- 카메라에 빛이 얼만큼 들어오는지를 모사
	<-- 눈에 적용효과(예:밝은 곳에서 갑자기 어두운 곳에서 들어가면 잘 안보이는 현상, 어두운 곳에서 갑자기 밝은 곳으로 나왔을 떄 눈부심)를 표현

 Bloom
	품질이 좋지 않은 렌즈에서 빛의 산란효과(뿌옇게 됨)를 모사
	<-- 게임에서는 흔히 뽀샤시 효과라고 부른다.

Chromatic Aberrtion 
	색수차 효과(색이 들어간 띠가 나타나는 현상)
	품질이 좋지 않은 저가 렌즈에서 빛을 구성하는 서로 다른 파장들이 각각 서로 다른 각도로 굴절되어 생기는 현상
	<-- 예) 저가 캠코더 촬영 느낌을 낼 수 있다.

Vignette
	품질이 좋지 않은 저가 렌즈에서 흔히 발생하는 현상
	가장자리가 중앙보다 어두워지는 현상

Lens Distortion
	렌즈에 외곽에 굴절 이상으로 사진이 왜곡되어 보이는 현상
	<-- 이 효과가 들어가면 좀 더 실제감이 느껴진다. (좀 더 렌즈로 찍은 것 같다.)




	  //delegate 델리게이트 (대리자) <--간접호출의 도구
	  public delegate void Func(); 델리게이트 선언

	  List<Func> tFunctions = new List<Func>()
	  {
		doIdle, doAttck, doDamage
	  };

	  mCurState = 0;
	  mCurState = 2;

	  tFunctions[mCurState](); <--간접호출

	  Console.ReadLine();
		

