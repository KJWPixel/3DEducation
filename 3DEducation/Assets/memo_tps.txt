memo_tps.txt

함수의 overload(함수의 중북정의)
:함수가 이름은 같고 매개변수 리스트가 다른 것.

함수의 override(함수의 재정의)
:부모클래스의 함수와 동일한 형태로 만들되
실제 정의의 구현은 다르게 하는 것.


OOP갹체지향 프로그래밍 코드의 4가지 특징

추상화 abstraction

은닉화 encapsulation

상속화 inheritance

다형성 polymorphism
 virtual + override + 부모클래스 참조 타입으로 다루기를 결합해서 만든다.


import
외부의 파일 자원을 유니티로 가져와 '에셋'화하는 동작

Asset
유니티가 사용하는 게임 자원resource


Scene Graph
장면 그래프
3D 상의 게임오브젝터들을 담고 있는 '자료구조'


변환 Transform
:자기자신으로의 사상(함수, 매핑mapping)\



렌더링 Rendering
:3D공간상에 정점 단위의 데이터를 
2D공간상에 픽셀 단위의 데이터를 이미지화시켜(프레임 이미지)표시하는 것

렌더링 파이프라인 Rendering Pipeline
렌더링의 일련의 공정들의 집합

일반적인 렌더링 파이프라인의 구조
===================================================================================================
응용프로그램 단계					기하 단계									  래스터라이즈 단계
===================================================================================================
응용프로그램이						월드변환	   (카메라변환)뷰변환	  투영변환
그래픽 처리가 필요한				 이동변환       이동변환
데이터와 명령문을					 회전변환       회전변환
조직화하여							 비례변환          X
그래픽 처리 장치로 
넘기는 작업
===================================================================================================
CPU, RAM							GPU, VRAM

									정점 데이터를 다룬다.						  픽셀 데이터를 다룬다.
									연속적인 공간을 다룬다.						  불연속적인 공간을 다룬다.



셰이딩 shading: '픽셀의 최종 색상'을 결정한다. (픽셀의 최종 색상 = f(물체의 색상, 텍스처, 조명) )

Material 재질: How to Shading. 어떻게 셰이딩할지에 대한 '데이터'와 '방법'을 담은 개념
'방법' Shader세이더: 세이딩하는 작은 조각프로그램


 알베도
 :빛 반사에 의한 색상


유니티에서 길이 단위는 1Unit을 쓴다.
유니티의 1unit은 실제 세계의 1m에 대응된다.
유니티의 무게단위는 1이 1kg에 대응된다.

rigidbody에
 Force계열: 물리 1초동안 주는 힘
 Impelse:        1프레임 동안 주는 힘

삼각형Triangle
:3개의 정점(vertex)이 선으로 이루어진 도형



3D그래픽스에서는
삼각형을 기본단위로 사용한다.
삼각형들을 모아서 임의의 입체도형(폴리곤 polygon)을 만든다


메쉬Mesh
<--삼각형들의 집합( 정점들의 집함 )


this: '객체' 자기자신을 가리키는 참조 변수, 암죽적으로 선언되어 있다. 생략 가능하다.




//변수의 선언과 초기화
int tA = 3;
//정수를 값으로 가지는 변수


int* tpA = nullptr;
//주소를 값으로 가지는 변수

class CSlime
{
	int mA = 0;

	private void Move();

}//사용자 정의 타입

CSlime tSlime;//객체


벡터의 회전rotation이란?
크기는 그대로이고 방향이 바뀌는 것

0_tps_followCam_0
 :간단한 3rd Person Shooter 카메라 시점과 이동을 만들어보자.

  캐릭터는 이동하고
  카메라는 따라간다.

  캐릭터 이동
    Rotate
	Translate


카메라 워크

instPCahr_Simple: 가장 간단한 카메라 워크 구현은 
		플레이어블 캐릭터에 계층구조 상 하위 오브젝트로 카메라를 두고
		자신이 워하는 시점으로 조정해두는 것이다.


스크립트를 이용한 TPS카메라워크
	LateUpdate <-- 렌더링된 경과를 담기 위해 이 위치에 코드
	Transform.LookAt <-- 뷰좌표계의 기저basis의 회전에 관한 것이다.

	Lerp을 이용한 DampTrace 추적감쇠 <-- 지연 카메라



직선의 방정식, 일차 함수 표준형
 y = ax + b

 게임 프로그래밍에서는 위의 직선의 방정식보다는
 '직선의 벡터 방정식'을 더 자주 사용한다.

 P = P0 + (P1 - P0) * t
  위치 + 벡터 * 스칼라

 임의의 점: P

 P0---------P----------------P1
 시점   임의의 점           종점



다음은 벡터와매개변수로 나타낸 선형보간 식이다.
P = (1-t) * P0 + t*P1 




0_tps_followCam_1
 :비교적 좀더 복잡한 ㄴ 3rd Person Shooter 카메라 시점과 이동을 만들어	보자.

  캐릭터는 이동하고
  카메라는 따라간다.

  캐릭터 이동 
	Character Controller 컴포넌트

오일러 수치해석에 의한 이동 코드를 이해해야 해당 컴포넌트를 이용 가능하다.
속도 = 거리의 변화량 / 시간의 변화량
V = deltaS / deltaT
  = (S[n] - s[n-1]) / deltaT

  V * deltaT = S[n] - S[n-1]

  S[n] = S[n-1] + V * deltaT



가속도 = 속도의 변화량 / 시간의 변화량
A = deltaV / deltaT
  = (V[n] - V[n-1]) / deltaT

   V * deltaT = V[n] - V[n-1]

   V[n] = V[n-1] + A * deltaT


   캐릭터 컨트롤러는
   Rigidbody물리를 활용하지 않는 캐릭터를 만들 때 사용한다.

   Slope Limit: 올라갈 수 있는 경사 한계 설정
   Step Offset: 계단으로 취급할 수 있는 높이 한계 설정
   Skin Width:  두 콜라이더가 서로 스킨 너비만큼 관통 가능
   <-- 이를테면 두 캐릭터가 이동하거나 할 때 서로 부딫히면 이 정도 허용오차는 
   주어 서로 끼는 현상을 방지하기 위한 옵션이다.

   지터링 Jittering
   :물결치듯 불안정하게 떨리는 현상

   다음은 메뉴얼에서 권장하는 수치이다.
   <--이를 기준으로 조정하여 사용하면 되겠다.

   신장: 2unit(2,)
   보폭: 0.1~0.4unit
   Slope Limit: 90 degree
   Skin Width: 최소 0.01초과, Radius의 10%보다 크게
   Min Move Distance:0
   

   transform.TransformDirection
   '로컬 좌표계 공간'에서 '월드 좌표계 공간'으로 direction을 변환 하는 함수이다. 


카메라
	
	i)vector = Quaternion * vector



사원수 Quaternion:

복소수는 다음과 같이 표기한다. ( 대수적인 표현 )

a + bi
실수부 + 허수부

복소수 * 복소수 가
2차원 평면에서 임의의 위치의 회전이 된다.

라는 사실을 보고 해밀턴 수학자는 이런 생각을 했다.
 3차원 공간에서 임의의 위치의 회전이 되는 '수'는 없을까?

 그래서 만들어낸 것이 항 4개로 표현하는 사원수Quaternion이다.
 그리고 이것은
 3차원 공간에서의 임의의 위치의 회전(벡터 포함)을 대수적을 표현한다.
 크기가 1인 사원수: 단위사 원수 


 q = w + 
 xi + yi = zk

  1    -1
 p = gpg
 회전된 방향 = 다윈사원수 * 원래방향 * 1


 데카르트(직교) 좌표계
 (x,y)

 극 좌표계
 x = r*cosT
 y = r*sinT 

 degree
 :한바퀴를 360등분한 것중에 하나를 1도라고 한 것
 측정치
 수학의 개념은 아니다.

 radian
 :반지름이 r인 원의 r만큼의 호의 길이를 1라디안이라고 한다.
 이것은 원의 개념으로부터 나온 것이므로 수학적 개념이다.
 (실수 연산에 통합된다)
 <-- 그러므로, 수학함수나 게임엔진에서는 내부적으로 radian각도개념을 사용한다.

 
 몇가지 회전의 종류를 비교해보자.
 i)   유니티 에디터 상에서 zxy순서로 90,90,90도 회전시키고 결과를 보자.		<--오일러 각의 의한 회전
 ii)  사원수의*연산자로 사원수 연산 적용 결과를 살펴보자.	 <--사원수의 의한 회전
 iii) transform.Rotate결과를 살펴보자.	 <--사원수의 의한 회전
 iv)  Quternion에서 제공하는 Euler함수를 적용 결과를 살펴보자.  <--오일러 각의 의한 회전
 v)   직접 회전행렬을 만들어 정점들에 적용, 결과를 보자. <-- 오일러 각의 의한 회전



 사원수의 곱셈이 3차원 공간에서
 임의의 벡터의의 회전을 나타내난 이유:

 벡터의 회전이란
 크기는 그대로이고, 방향변경되는 것을 말한다.

 임의의 벡터를 사원수에 곱셈하여
 임의의 회전된 벡터를 얻는 식은 다음과 같다.

 p' = qpq^-1

 p':   임의의 벡터
 p:    임의의 회전된 벡터
 q:    회전에 해당하는 사원수
 q^-1: q의 역수

 회전에 사용되는 사원수는 단위사원수이다.(크기가 1인 사원수)
 그러므로 q와 q^-1은 단위 사원수이다.
 그러므로
 q^-1와 q*는 같다
 (q*은 q의 공액이라고 한다. 벡터부가 반대인 사원수이다.)

 그러므로 다음은 다르게도 쓸 수 있다.
 p' = qpq^-1

 p' = qpq*

 크기를 구하자

 ||p'|| = ||qpq*||
 ||p'|| = ||q||, ||p||, ||q*||

 ||p'|| = ||p||

 방향을 구하자 
 p' = qpq*
	= [Qs Qv][0 Pv][Qs-Qv]

	그리고 이를 사원수의 연산을 활용해 풀이하면
	= [0 V]
	
	임의의 회전된 방향의 벡터가 나온다

	정리하면
	사원수의 곱셈의 결과가
	크기는 변하지 않고 임의의 회전된 방향의 벡터가 나오므로
	사원수의 곱셈은
	3차원에서 벡터의 회전을 대수적으로 표현한다고 할 수 있다.



2_thrad_vs_conroutine

	프로세스Process: 프로그램 실행의 흐름
	   스레드Thread: 실행 흐름의 최소 단위

	  프로세스는 N(N>=1)개의 스레드로 이루어진다.

	  스레드 1개의 프로세스 1개 ---> 싱글 스레드 프로그램
	  스레드 N개(N>=2)에 프로세스 1개 ---> 멀티 스레드 프로그램

	  멀티 스레드 프로그램의 목적: 
		단위시간 당 병렬 처리(동시에 실행흐름을 여러개 실행한다)를 통해 더 많은 연산을 하려는 것이 목적이다.


	C#에서 제공되는 
	코루틴Coroutine은 병렬 처리를 흉내내기 위해 만들어진 개념이다.
	다만, 
	코루틴은 실제로 병렬 처리되는 것은 아니다.
	코드만 그런 형태를 취한다.


3_AI_Navigation
	
	<--A*알고리즘: 게임업계에서 길찾기에 사용하는 대표적인 알고리즘(필수)
	f = g + h
	f: 현재 판단가능한 최선의 비용
	g: 현재지점까지의 실제비용
	h: 현재지점에서 최종지점까지의 추정비용 


	유니티에서 제공하는 인공지능 길찾기

	AI Navigation 패키지 설치가 필요하다. (2022.3.4f1 기준)

	다음 세가지 컴포넌트가 주요하다.

	i) NavMeshSurface
		새롭게 추가된 컴포넌트이다. (기존에는 장면 단위로 관리되었었다.)

		지형 정보를 구축한다. (Bake(미리 정보를 계산하여 '파일'로 가지고 있는다)한다 라고 표현한다.)
		장면이름과 같은 폴더가 만들어지고 그곳에 에셋 파일로 저장된다.

		여러가지 지형 정보 생성 방식을 지원한다.(예: volume, ...)

		<--Generate Links
		:( OffMesh Link기능이다)
		서로 떨어진 메쉬를 이동할 수 있게 연결 정보를 만드는 것이다.
		지형정보에 대해 전역적으로 생성된다.
		방향은 한 방향이다.(높은데서 낮은데로)


		<--OffMeshLink컴포넌트
			컴포넌트를 부착하여 만든다.
			시작점 끝점 지정 가능하다.
			베이크 정보에 포함되지 않는다.

		<--NavMeshLink컴포넌트
			컴포넌트를 부착하여 만든다.
			시작점, 끝점 지정 가능하다.
			베이크 정보에 포함되지 않는다.

			서로 다른 베이크된 지형 정보 사이에 이동도 가능하다.

	ii) NavMeshAgent
		
		미리 베이크된 지형정보를 기반으로
		길찾기를 수행, 게임 오브젝트를 이동시킨다.

	iii) NavMeshObstacle

		실행중에 작동하는 동적 장애물을 만드는 컴포넌트

		Carve옵션을 켜야만 작동한다.
		Carve Only Stationary On 움직임이 없다고 판단되었을 때 장애물로 인식하도록 연산한다. <-- 실행중 연산이 비교적 작다.
		Carve Only Stationary Off 움직이는 동안에도 장애물로 인식하도록 연산한다. <--실행중 연산이 많다

	iv) NavMeshModifire

		NavMesh Data 수정(변경)자

		예) 만약 이동불가 지역을 만드려면
		해당 지역에 해당하는 게임오브젝트에 NavMeshModifire컴포넌트를 부착하고
		Override Area/Area Type을 Not Walkable로 설정한다.

		Navigation윈도우의 Area탭에서
		사용자 정의 커스텀 Area도 만들 수 있다.
			Cost설정도 가능하다.


4_Behaviour Tree

	행동 트리
	트리의 구조와 체계를 가져와 
	임의의 행동을 결정하는 게임 인공지능 이론으로 사용한다.

	
	게임 인공지능의 주요한 두가지 기법
	  i)FSM: Finite State Machine 유한상태기계
		유한한 상태들의 추상적인 기계

	  ii)Behaviour Tree
		

